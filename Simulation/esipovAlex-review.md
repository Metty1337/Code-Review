# Review на реализацию от [@esipovAlex](https://github.com/esipovAlex) проекта [Симуляция](https://zhukovsd.github.io/java-backend-learning-course/projects/simulation/)

## Реализация

Привет, давай сначала пройдемся по твоей реализации:

### Плюсы

- Отображение кол-во живых существ.
- Корректное завершение работы.
- Имеется возможность детальной настройки путем изменения конфига.
- Реализована пауза - причем вводом пробела, что довольно интересно.

### Замечания

- Не сразу понятно - есть ли пауза или нет (узнать про ее наличие можно только из _readme_), хотелось бы какое-то
  оповещение об этом в самой симуляции.

## По коду

### package world

- В текущем виде переопределение методов _equals()_ и _hashcode()_ в _record Coordinate(int x, int y)_ излишне. В Java _record_
  автоматически генерирует корректные реализации _equals()_ и _hashcode()_.
- Не ясное имя у _enum Names_. Слишком слабо описывает содержимое. В классе находится представление _Entity_ в виде
  эмоджи для рендера и имя должно быть соответствующим - например EntitySymbol или EntityType etc. А сам класс должен
  находиться в пакете рядом с классом, который отвечает за рендер.
- Про класс _Universe_:

1) В данном случае не стоит использовать общую аннотацию _@Setter_ над классом, иначе класс теряет контроль над своим
   состоянием и любой внешний код может изменить то, что не должен был.
2) Поле _Names[][] names_ - нарушение SRP, не стоит смешивать модель и представление.
3) Сейчас в себе класс содержит аж 6 коллекций для каждого типа существа, выглядит как нарушение принципа _KISS_ -
   хватило бы сделать только одну коллекцию для хранения существ и их расположения, к тому же это прямо сказано
   в [ТЗ](https://zhukovsd.github.io/java-backend-learning-course/projects/simulation/#map).
4) Довольно логичным было бы добавить всем коллекциям модификатор _final_, добавив перед этим интерфейс для работы с
   ними.
5) Поле _int stepId_ - нарушение SRP, наша *вселенная* не должна знать ничего о ходах. Стоит это вынести в другой класс.
6) Судя по ТЗ, роль Universe ближе к карте, однако сейчас класс берет на себя слишком много дополнительных обязанностей.
7) Методы _refreshHerbivore_ и _refreshPredator_ тоже берут на себя чужую ответственность по перемещению существ.

### package models

- _Entity_ хранит в себе свои координаты. Такое решение требует строгой синхронизации с картой, иначе возможен рассинхрон данных. Как вариант - не хранить координаты в _Entity_, а оставить их Карте.
- `return path.size() > 1 ? path.get(1) : start` - в данном месте тернарный оператор снижает читаемость, т.к. выражение не тривиально. (опционально)
- Метод _move_ у класса _Creature_ вместо ходьбы самим существом, возвращает некое _DTO_ _NextStep_, что сбивает с
  толку.
- В этом же методе переменная _remove_ - не очевидно, что за цель для удаления. Можно переименовать, например,
  _targetToRemove_.
- Следует избегать комментариев, дублирующих логику кода. Предпочтительнее самодокументируемый код и говорящие имена.
- Отсутствие конструктора для инициализации поля _hp_ в _Creature_ ведет к возможности создания существа без здоровья.
- То же самое касается поля координат в Entity - базовое состояние объекта лучше задавать через конструктор.
- Существа не имеют скорости - нарушение _ТЗ_.
- _Predator_ имеет поле _attack_, но оно нигде не используется - нарушение _ТЗ_.
- То же самое с _hp_ в _Creature_, которое никак не используется - нарушение _ТЗ_.

### package createactions

- У единственного метода интерфейса _CreateAction_ - _void create_ неясное название - метод как бы что-то создает, но
  при этом ничего не возвращает. Полагаю, имелось в виду значение выполнить, тогда и название _execute_ подойдет больше.
- Класс _FillEntity_:

1. Сбивающее с толку название - суть класса инкапсулировать логику вызова всех _CreateAction_, тогда подошло бы название
   _EntityFiller_.
2. Сейчас список _List< CreateAction> actions_ жестко закодирован в конструкторе, что делает его трудно изменяемым при
   расширении. Предлагаю принимать в конструктор из вне сам _List< CreateAction> actions_ и присваивать полю.

- Класс _CoordinateGenerator_:

1. Переменную _Set< Coordinate> target_ лучше назвать в множественном числе, так будет логичнее, ведь это множество.
2. Если ты не хочешь иметь реализацию в абстрактном классе, то стоит просто оставить его с модификатором _abstract_, не
   оставляя его просто пустым.
3. Класс _CoordinateGenerator_ является абстрактным классом, при этом реализуя интерфейс _CreateAction_, а наследниками
   _CoordinateGenerator_ являются классы по типу _GrassCreateAction_, что явно не выглядит хорошо. Такое наследование
   нарушает принцип _is-a_ - объекты травы не являются генераторами координат.

- Для решения проблемы наследования предлагаю либо использовать утилитарный класс или воспользоваться композицией.

### package service

- Странное название у _InitWorld_. Название должно быть существительным - подошло бы _WorldInitializer_.
- Класс _InitWorld_ не только создает нашу вселенную, но и сам заполняет ее - нарушение SRP.
- Класс ReadProperties_:

1. Класс _ReadProperties_ стоит назвать сущностью, а не глаголом. Например - _PropertiesReader_.
2. На ошибку стоит реагировать соответственно - имеет смысл пробросить unchecked-исключение с понятным сообщением, т.к. без конфигурации приложение не может продолжить работу.

- Класс _RenderWorld_:

1. Хочется поменять название на _WorldRenderer_ для читаемости - "рендерер для мира".
2. Метод _prepare_ - не просто "подготавливает", но и мутирует объект _universe_, что немного противоречит названию
   метода.
3. Класс одновременно и "подготавливает" и рендерит мир - нарушение SRP.
4. Переменная _Names[][] arrNames_ не стоит использовать венгерскую нотацию, вместо этого просто _names_ - так будет
   понятно, что множественное число означает коллекцию, а благодаря средствам _IDEA_ легко узнать какая именно
   коллекция, что в конечном итоге улучшит читабельность.

### Simulation

- Я бы вынес метод _main_ в отдельный класс, иначе получается ситуация, где внутри класса - создается экземпляр этого же
  класса.
- Предпочтительнее не импортировать статические методы, ради ясности источника зависимости.

```
// вместо
out.println(...);

// лучше
System.out.println(...);
```

- По ТЗ класс должен содержать в себе поля Карты, Счетчика ходов, Рендерера поля, Actions - ничего из этого нет - нарушение ТЗ.
- По ТЗ класс должен иметь в себе методы _nextTurn()_, _startSimulation()_, _pauseSimulation()_ - их тоже нет - нарушение ТЗ.
- Не ясное название метода _renderWithUniverse_, сразу возникают вопросы "Значит мы можем рендерить без *Вселенной*?"
- Переменная _stepId_ является на самом деле счетчиком - нужно соответствующие название.
- Не стоит игнорировать подсказки _IDEA_ - тип переменных _renderSleep_ и _pauseSleep_ лучше заменить на примитивный.
- Метод _isLoopRender_ предполагает, что _loop_ всегда имеет три элемента. Это хрупко - если _fillLoop_ будет вызван некорректно, то будет исключение.
- Метод _renderWithUniverse_ получился довольно объемных - стоит подумать как его можно разбить на несколько вспомогательных методов.
- Использование _stream().forEach()_ на списках, где достаточно обычного цикла _for_ только снижает читабельность кода.
- Название поля _List<Names[][]> loop_ неочевидно, ведь оно используется для хранения истории кадров. Лучше _previousRenders_.
- class _KeyListener_ внутри _Simulation_ - нарушение _SRP_. Стоит вынести в отдельный класс и запускать потоки из _main_. 
- Считаю, что класс стоит переделать - адаптировать под ТЗ.

## Итоги

- Не стоит игнорировать замечания от *IDEA* - почти всегда это по делу, если ты специально не хочешь сделать по другому.
- В проекте встречаются магические цифры/строки - стоит вынести в константы.
- Ключевая проблема - размытые ответственности классов: _Universe_, _Simulation_, _RenderWorld_ берут на себя слишком много ролей, что приводит к _God Classes_ и усложняет расширение.
- Несколько требований ТЗ не реализованы или реализованы формально (скорость существ, атака, использование hp, структура карты), что критично.
- Рекомендую глянуть чужие реализации этого проекта.
- Самым важным считаю переработку классов Simulation, Universe.
- После рефакторинга считаю можно переходить к следующим проектам. Успехов!