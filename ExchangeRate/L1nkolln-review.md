# Review на реализацию от [@L1nkolln](https://github.com/L1nkolln) проекта [Обмен валют](https://zhukovsd.github.io/java-backend-learning-course/projects/currency-exchange/)

### Вся предложенная критика не более чем субъективный взгляд, не стоит принимать за чистую монету.

## Реализация REST API
### GET /currencies
- Получение списка валют происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

### GET /currency/*
- Получение конкретной валюты происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

### POST /currencies
- Добавление новой валюты в базу происходит корректно.
- Не совсем точное сообщение при отсутствии нужного поля - оно пишет, что все поля отсутствуют, а не предполагает, что какое-то из полей пустое. 
```json
{
    "message": "Поля 'code', 'name', 'sign' пустые"
}
```
- Присутствует валидация для кода валюты, но также хотелось бы и для имени и символа валют.

### GET /exchangeRates
- Получение списка всех обменных курсов происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

### GET /exchangeRate/*
- Получение конкретного обменного курса происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

### POST /exchangeRates
- Добавление нового обменного курса в базу происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

### PATCH /exchangeRate/*
- Обновление существующего в базе обменного курса происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

### GET /exchange?
- Расчёт перевода определённого количества средств из одной валюты в другую происходит корректно.
- HTTP коды и *JSON* ответы соответствуют ТЗ.

## По коду

### package dao
- Огромный плюс, что мы имеем интерфейс, который позволяет нам не зависеть от реализации, но он с небольшим нюансом, о котором ниже написано.
- В обоих реализациях поля часто находятся ниже методов, что нарушает *Java-конвенцию* по оформлению кода. Всегда поля должны идти выше методов.
- Интерфейс призван реализовывать абстракцию и полиморфизм, но в нашем случае он ничего из этого не делает, а если и делает, то только частично, так как содержит лишь пересечение нужных методов для двух наших реализаций, что делает невозможным полиморфное использование в полном объеме.
```java
// и вместо корректного использования:
public final Dao<Integer, Currency> currencyDao = new CurrencyDao();

// у нас получается вот это:
public final CurrencyDao currencyDao = new CurrencyDao();
```
- Для решения этого предлагаю расширить интерфейс *Dao* двумя новыми интерфейсами *CurrencyDao* и *ExchangeRateDao*, в которых будут специфичные методы. В таком случае названия реализаций станет что-то вроде *JdbcCurrencyDao* и *JdbcExchangeRateDao* и мы сможем пользоваться благами интерфейса.

### CurrencyDao
- Так же обращу внимание на обработку исключений в этом же методе при не нахождении валюты, на мой взгляд это является частью бизнес логики, и не суждено слою, отвечающим за доступ к базе данным, лезть в обработку бизнес исключения. Предлагаю обрабатывать этот случай в слое сервиса, которого, кстати, в проекте, к сожалению, нет.
- Точно так же в методе *void update(Currency entity)* предлагаю вместо обработки *NotFoundException* возвращать кол-во обновленных строк и проверять корректность значения уже в слое сервиса.
```java
// вместо
public void update(Currency entity) {
    //...
    if (updatedRows == 0) {
                throw new NotFoundException("Валюта с id= " + entity.getId() + " не найдена");
            }
//...

// предлагаю  
public int update(Currency entity) {
    //...
    return preparedStatement.executeUpdate();

// и где-то в сервисе уже обрабатывать
if (updatedRows == 0) {
                throw new NotFoundException("Валюта с id= " + entity.getId() + " не найдена");
            }

```
- Все выше перечисленное так же относиться и к *Currency create(Currency entity)*
- На мой вкус не совсем подходящее название у *Currency buildCurrency(ResultSet resultSet)*, предложу *parseCurrency*, которое более точно описывает происходящее в методе.

### ExchangeRateDao
- В *ExchangeRateDao* очень похожая ситуация, пункты выше так же применимы к нему.
- Закоментированный код, от которого лучше избавляться перед коммитами в *void update(ExchangeRate entity)*

### 
- В Java пакеты обычно называются в единственном числе.
- В целом стандартный пакет эксепшенов. Единственное, разве что, рекомендовал бы не хардкодить сообщения об исключении, а инжектить их в конструктор.
```java
// вместо 
public DatabaseException(Throwable cause) {
        super("Ошибка базы данных", cause);
    }

// предлагаю
public DatabaseException(String message, Throwable cause) {
        super(message, cause);
    }
```

### Model

### Currency 
- Советую использовать String.format() вместо бесконечной конкатенации - это заметно облегчает чтение кода. (стилистическая рекомендация)
```java
// вместо 
@Override
    public String toString() {
        return "Currency{" +
                "id=" + id +
                ", code='" + code + '\'' +
                ", fullName='" + name + '\'' +
                ", sign='" + sign + '\'' +
                '}';
    }

// лучше
@Override
    public String toString() {
        return String.format("Currency{id=%d, code=%s, name=%s, sign=%s}", id, code, name, sign);
    }
```
- Того же самое касается в *ExchangeRate* *String toString()*.
```java
// вместо
    @Override
    public String toString() {
        return "ExchangeRate{" +
               "id=" + id +
               ", baseCurrencyId=" + baseCurrencyId +
               ", targetCurrencyId=" + targetCurrencyId +
               ", rate=" + rate +
               ", baseCurrency=" + baseCurrency +
               ", targetCurrency=" + targetCurrency +
               '}';
    }

// лучше
@Override
    public String toString() {
        return String.format("ExchangeRate{id=%d, baseCurrencyId=%d, targetCurrencyId=%d, rate=%s, baseCurrency=%s, targetCurrency=%s}", id, baseCurrencyId, targetCurrencyId, rate, baseCurrency, targetCurrency);
    }
```
- Почти все методы класса *Currency* и *ExchangeRate* это обычный *boilerplate* код, который легко можно заменить на аннотации того же *Lombok* - советую ознакомиться.
- Непонятно зачем тебе одновременно поля с *id* валют и эти же самые валюты в других полях. Сейчас из-за этого твой класс выполняет одновременно две роли - как *DTO*, так и *Model*. Лучше использовать отдельно *DTO* для общения с сервисом и контроллером, оставив модель исключительно для *DAO* слоя.
```java
// вместо
public class ExchangeRate {
    private Integer id;
    private int baseCurrencyId;
    private int targetCurrencyId;
    private BigDecimal rate;
    private Currency baseCurrency;
    private Currency targetCurrency;
}
// лучше 
public class ExchangeRate {
    private Integer id;
    private int baseCurrencyId;
    private int targetCurrencyId;
    private BigDecimal rate;
}

public class ExchangeRateDto {
    private Integer id;
    private CurrencyDto baseCurrency;
    private CurrencyDto targetCurrency;
    private BigDecimal rate;
}
```
### Servlets

- Имена пакетов в Java обычно пишут в единственном числе, вместо *servlets* - *servlet*.
- В целом почти во всех методах пакета *servlets* хотелось бы побольше декомпозиции, дабы методы не были такими большими.

### currency

- Валидации желательно не находиться в сервлетах. Обработку исключений предпочтительнее вынести в фильтр. Как вариант - `ExceptionHandlerFilter implements Filter`, который будет отлавливать исключения и устанавливать корректные статус и сообщения в ответ.
- Мы пишем *REST API* и, на мой взгляд, хочется сервлет назвать в таком же стиле. Вместо *GetCurrencyServlet* более подходящим было бы *CurrencyServlet* 

### exchangeRate
- Тоже самое про логику относится и к этому пакету.
- Если мы хотим воспользоваться функцией логгера, то стоит его использовать вместо обычного печатания в консоль.
```java
// вместо
e.printStackTrace();

// например
log(e.getMessage());
```
- Неподходящее название по той же причине, что и выше у *GetAndAddExchangeRatesServlet* лучше *ExchangeRatesServlet*.
- Так же всю валидацию и обработку исключений вынести в *filter*.
- Неподходящее название по той же причине, что и выше у *GetAndPatchExchangeRateServlet* лучше *ExchangeRateServlet*.
- Странно, что один класс остался просто висеть в *servlets*, когда остальные были распределены. Как вариант - добавить его в пакет *exchange*.
- Советую не использовать тернарный оператор - на мой взгляд, сильно затрудняет чтение.
- *ExchangeServlet* это класс, который наиболее сильно нуждается в сервисном слое. Вся бизнес-логика перевода валют не должна быть в сервлете, на то есть сервис.
- Тяжело читать метод *doGet* из-за его гигантского объема и размытой ответственности - признаки *GodMethod*. Решение - в сервис вынести необходимые методы, которые будут вызываться по нужде в контроллере.

### Utils
- Пакеты в Java обычно называются в единственном числе.
- Принято, что все утилитарные классы должны иметь единственный приватный конструктор и модификатор *final*.
```java
// вместо
public class ErrorHandler {}
// скрытый конструктор

// правильно
public final class ErrorHandler {
    private ErrorHandler() {}
}
```
- В классе *DatabaseManager* в *getConnection*() нет смысла возвращать обычный *RuntimeException*, когда в проекте уже есть *DatabaseException*
```java
// вместо
catch (ClassNotFoundException e) {
            throw new RuntimeException();
        }

// лучше 
catch (ClassNotFoundException e) {
            throw new DatabaseException();
        }
```
- *ErrorHandler* название слишком абстрактное, что сильно размывает ответственность класса и не ясно с первого взгляда, что конкретно он должен делать.
- В целом не понятно зачем нужен *ErrorHandler*, если у нас есть тот же *HttpUtil*, который может в аргументы принимать все то же самое, что делает единственный метод *ErrorHandler*. Из-за этого в верхеуровневом слое не ясно какой Http код стоит ожидать в случае исключения.
- *ExchangeResponse* выполняет роль *DTO* и стоит перенести в соответствующий пакет.
- Неиспользуемые методы стоит удалить.

### DatabaseTest

- Класс - утилита для проверки работы с базой. На мой взгляд - полезен для разработки, но не должен использоваться в *production* коде. В следующих проектах вы познакомитесь с тем, как правильно писать тесты.

## Общее
- Не стоит игнорировать замечания от *IDEA* - почти всегда это по делу, если ты специально не хочешь сделать по другому.
- Местами не хватает форматирования, настоятельно рекомендую использовать *Reformat Code (Ctrl + alt + L)*
- Ввести сервисный слой, не стоит хранить бизнес-логику где попало.
- *DAO-интерфейс* реализован формально и не даёт реальной абстракции. Надо разделить его на специализированные интерфейсы (*CurrencyDao*, *ExchangeRateDao*) и использовать их полиморфно.
- Логику обработки исключений и конвертацию ошибок рекомендую вынести в отдельный *ExceptionHandlingFilter*.
- В проекте используются пакеты то во множественном числе, то в единственном - стоит привести к единому стандарту.  
- В проекте присутствуют магические числа/строки, которые имеют бизнес значения - их стоит выносить в константы.
- Много закоментированного кода - стоит убирать.
- Модели *Currency* и *ExchangeRate* совмещают роли *Entity* и *DTO*. Рекомендую разделить модель предметной области и *DTO* для *API*.
- Большая часть **boilerplate*-кода* может быть заменена *Lombok*.
- Обычно всю *.idea* добавляют в .gitignore, советую поступить также.
# Итоги
- Работающий проект, есть над чем поработать.
- Считаю необходимым рефакторинг больных моментов и можно двигаться дальше. Удачи!
