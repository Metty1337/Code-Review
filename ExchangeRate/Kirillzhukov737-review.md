# Review на реализацию от [@Kirillzhukov737](https://github.com/Kirillzhukov737) проекта [Обмен валют](https://zhukovsd.github.io/java-backend-learning-course/projects/currency-exchange/)

[Сама реализация](https://github.com/Kirillzhukov737/currency-exchange)

## Реализация REST API

- К сожалению, деплоя у проекта нет, а собрать локально мне не удалось из-за некорректно настроенного docker-compose.
  Если возникли проблемы, то советую выбрать более простой способ интеграции фронтенда - просто положить статические
  файлы внутрь проекта, чтобы index.html был доступен по корневому пути.

## По коду

### package model

- Как вариант улучшения предлагаю рассмотреть использование _Long_ в качестве _id_ вместо _int_.
- Использование _record_ для модели, которую ты "вставляешь" в БД - имеет свои ограничения. И ты уже успел с ними
  столкнуться. Как вариант - использовать обычный _mutable_ класс для моделей, а record оставить для _DTO_.

### package dao

- Название классов _CurrencyDAOImpl_ и _ExchangeRateDAOImpl_ не настолько информативны как могли бы быть, плюс _DAO_
  обычно пишут так же как и обычные слова - в CamelCase. Более хорошим вариантом были бы названия: _JdbcCurrencyDao_ и
  _JdbcExchangeRateDao_.
- Стандартный стиль большинства Java-проектов - публичные методы стоят сверху, приватные снизу. Таким образом, когда
  кто-то открывает класс - он сразу видит публичный _API_, а детали реализации скрыты ниже.
- Класс _CurrencyDAOImpl_:

1. Опечатка в `String FIND_BY_CODE`:

```
 private static final String FIND_BY_CODE = """
            "SELECT id, code, full_name, sign // лишние кавычки
            FROM currencies 
            WHERE code = ?
            """;
```

2. (optional) В данный момент _DAO_ слой реализован для удобства использования сервисом. Как пример - метод
   `Currency save(Currency currency)`, который возвращает объект, хотя в канонической реализации _DAO_ с _JDBC_ метод
   _save_ ничего не должен возвращать. В чистой архитектуре слой _DAO_ ничего не должен знать каким образом его
   собираются использовать.
3. Поля класса написаны в разной форме - у некоторых _SQL_ запрос разбит по строкам, у некоторых нет - стоит привести к
   единому стилю.
4. В названиях констант можно добавить суффикс _SQL_.
5. В случае исключения выбрасывает _RuntimeException_ - хотелось бы иметь более конкретное исключение.

- Класс _ExchangeRateDAOImpl_:

1. Поля класса написаны в разной форме - у некоторых _SQL_ запрос разбит по строкам, у некоторых нет - стоит привести к
   единому стилю.
2. В названиях констант можно добавить суффикс _SQL_.
3. В `String FIND_BY_ID` встречаются лишние пробелы - не стоит игнорировать замечания _idea_, которые указывают на это.
4. В случае исключения выбрасывает _RuntimeException_ - хотелось бы иметь более конкретное исключение.

- Правильное использование _Optional_ для методов нахождения объекта в _БД_.

### package repository

- Название пакета не соответствует содержимому. Пакет _repository_ по смыслу должен содержать абстракции и реализации
  доступа к данным. В данном проекте эту цель выполняет пакет _dao_. Класс _DatabaseConnector_ является
  инфраструктурным, а не слой доступа к данным. Его стоит поместить в пакет с названием по типу config, datasource или
  хотя бы в utility.
- Исключение не стоит "приплюсовывать" к сообщению, лучше просто через запятую в качестве аргумента.

```
catch (IOException e) {
            throw new RuntimeException("Error database " + e);
        }

// лучше
catch (IOException e) {
            throw new RuntimeException("Error database ", e);
        }
```

- Класс нарушает _SRP_, т.к. и читает конфигурацию, и парсит свойства, и конфигурирует пул, и управляет _DataSource_.
  Как вариант решения - разбить на несколько классов.

### package service

- Большой плюс иметь интерфейсы для сервисов.
- _Impl_ - суффикс в названии сервисов, из-за него получается довольно слабое имя. Он говорит только, что это реализация
  интерфейса.
- Класс _CurrencyServiceImpl_:
    - Недостаточно информативное исключение _ConflictException_ для случая, когда валюта уже существует - лучше подошло
      бы _CurrencyAlreadyExist_.
    - Вставлять в модель `id = 0` перед ее сохранение в _БД_ - не лучший вариант. Лучше по-стандарту давать null для id,
      давая _DAO_ слою самому установить верное значение для модели.
- Класс _ExchangeRateServiceImpl_:
    - _CurrencyDao_ - сервис не должен напрямую использовать _DAO_ другого сервиса, если уже
      есть существующий сервис, который инкапсулирует работу с этим _DAO_.
    - Недостаточно информативное исключение _ConflictException_ для случая, когда валютная пара уже существует - лучше
      подошло бы _ExchangeRateAlreadyExist_.
    - Вставлять в модель `id = 0` перед ее сохранение в _БД_ - не лучший вариант. Лучше по-стандарту давать null для id,
      давая _DAO_ слою самому установить верное значение для модели.
    - Неиспользуемый метод `ExchangeRateDTO update(int id, ExchangeRateUpdateDTO dto)`.
- Класс _ExchangeServiceImpl_:
    - _ExchangeRateDAO_ и _CurrencyDAO_ - сервис не должен напрямую использовать _DAO_ другого сервиса, если уже
      есть существующий сервис, который инкапсулирует работу с этим _DAO_.
    - Хотелось бы более информативное исключение, чем _IllegalArgumentException_.
    - Реализован только один способ перевода валюты - нарушение _ТЗ_.

### package servlets

- _CorsServlet_ - нарушение SRP, помимо установки _CORS_ заголовков он еще и создает сервисы для использования другими
  сервлетами. Если есть желание использовать Service Locator паттерн, то лучше будет использовать встроенный
  ServletContextListener.
- Устанавливать _CORS_ заголовки в сервлете имеет ряд недостатков. Лучше воспользоваться фильтром, например
  _CorsFilter_, и тогда не придется использовать наследование и вызывать _addCors()_ во всех методах.
- Обработку исключений тоже стоит вынести в отдельный _filter_.

### package exception

- Класс _GlobalExceptionHandler_:
    - В методе _handle_ ошибка в использовании _if-else_, что может стереть верный статус.
    ```
            if (e instanceof NotFoundException) {
                response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            }
            if (e instanceof IllegalArgumentException) {
                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            } else {
                response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
  
  // лучше 
              if (e instanceof NotFoundException) {
                response.setStatus(HttpServletResponse.SC_NOT_FOUND);
            }
            else if (e instanceof IllegalArgumentException) {
                response.setStatus(HttpServletResponse.SC_BAD_REQUEST);
            } else {
                response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            }
  ```
    - Класс нарушает OCP, стоит рассмотреть какой-нибудь способ решения этого.
    - Сам класс является утилитарным - значит у него должен быть закрытый конструктор и _final_ модификатор.
- Исключений в пакете слишком мало - хотелось бы побольше специфических исключений.

### package utility

- _PingServlet_ - закомментированный класс.
- Как вариант улучшения фабрики сервисов - вынести _DAO_ классы в поля в качестве _singletone_.

## Общее

- Не игнорируй замечания от idea - чаще всего они полезны.
- Магические числа/строки стоит заменять константами.
- Как вариант улучшения мапперов - можно ознакомиться с _MapStruct_.
- Неплохо было бы оформлять коммиты в соответствии
  с [конвенцией](https://gist.github.com/qoomon/5dfcdf8eec66a051ecd85625518cfd13).
- Хорошо было бы узнать про правильное оформление _pom.xml_.

# Итоги

- Без деплоя не ясно, насколько верна реализация, а по коду - есть над чем поработать. После деплоя и рефакторинга думаю можно смело переходить к следующему проекту.
