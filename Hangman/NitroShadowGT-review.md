# Review на реализацию от [@NitroShadowGT](https://github.com/NitroShadowGT) проекта [Виселица](https://zhukovsd.github.io/java-backend-learning-course/projects/hangman/)

### Вся предложенная критика не более чем субъективный взгляд, не стоит все принимать за чистую монету.

## Реализация
- Было бы плюсом иметь *case-insensitive* ввод пользователем.
```
Начать игру - y
Выйти из приложения - n
Y
Нужно ввести y или n.
Попробуйте еще раз: 
```
- Несоответствие ТЗ - не выводится виселица после правильно угаданной буквы.
```
Ваша буква: а
Есть буква.
Ваше количество ошибок: 0
Состояние слова: _а_____
Введите букву:
```

- Нет валидации на ввод пользователем букв, можно ввести любой символ любой длинны.
```Ваша буква: ,
Нет буквы.
Ваше количество ошибок: 2
Состояние слова: _а_____
```

- Можно дважды ввести одну и ту же неправильную букву, за что будет дважды засчитана ошибка, а не единожды.
```
Ваша буква: д
Нет буквы.
Ваше количество ошибок: 1

Ваша буква: д
Нет буквы.
Ваше количество ошибок: 2
```

- Та же ситуация и с правильно введенной буквой, хотелось бы отображение, что буква уже была угадана.

- Пускай этого нет в ТЗ, но было бы огромным плюсом иметь перед глазами пользователя список введенных букв, дабы не запоминать уже введенное.

- Буква 'ё' в целом не принимается.
```Ваша буква: ё
Нет буквы.
Ваше количество ошибок: 3
Состояние слова: самоле_
```

- При проигрыше не отображается загаданное слово.
```
Ваша буква: a
Нет буквы.
Ваше количество ошибок: 6
Состояние слова: _______
------
|    |
|    O
|   /|\
|   / \
|
====
Игра окончена. Вы проиграли.
```

- Очень маленький пул слов, которые могут быть загаданы.

- В остальном же работа корректна.

## Общие замечания

- Сейчас у тебя в репе на гитхабе чисто один класс с кодом, что не является хорошей практикой. В идеале стоит начать создавать гит репозиторий в *IDEA*, которая сама тебе создает некую начальную структуру проекта, которой у тебя нет (даже не смотря на то, что проект в одном классе, не хватает банального пакета *src*, который отделит твои исходники от других файлов), чтобы тебе и другим было легче обозревать твой код.

- Не стоит игнорировать замечания от *IDEA* - почти всегда это по делу, если ты специально не хочешь сделать по другому.

- Местами не хватает форматирования, настоятельно рекомендую использовать *Reformat Code (Ctrl + alt + L)*

# По коду

- Комментарии по коду по всему проекту сильно ухудшают читаемость самого кода, код должен быть самодокументируемым.

## Main

- Если используешь какие-то ресурсы, то стоит их закрывать в конце цикла жизни.
```java
Scanner input = new Scanner(System.in);
// ....
input.close();
```

- Непонятно зачем слово загадывается в *main*, лучше сделать это в том же *gameLoop*. А то получается так, что мы загадываем слово еще до начала самой игры.
```java
String secretWord = getRandomWord();
```
- Как уже было сказано выше, стоит сделать *case-insensitive* ввод.
```java
// вместо:
startOrEndGame(input).equals("y")

// сделать
startOrEndGame(input).equalsIgnoreCase("y")
```
- Не стоит хардкодить значения констант, лучше вынести в поля класса как final.
```java
// вместо
System.out.println("До встречи!");

// лучше
public class Main {
    private static final String GOODBYE = "До встречи!";
// .....
System.out.println(GOODBYE);
```
Тоже самое касается всего проекта, дальше не повторяюсь.

# getRandomWord
- Не стоит хранить список загадываемых слов в массиве. Лучше считывать слова из файла, так мы исправим проблему низкого объема слов, при этом не увеличив кол-во строк кода.
```java
String[] words = new String[]{"автомобиль", "бассейн", "самолет", "тетрадь", "телефон", "леопард", "асфальт", "кровать", "яблоко"};
```
- Не стоит игнорировать подсказки от *IDEA* - он позволяет сделать код более читабельным.
```java
// вместо
String randomWord = words[randomIndex]; // случайное слово
return randomWord;

// лучше
return words[randomIndex];
```

# gameLoop

- На мой вкус этому методу больше подходит имя *startGame*, нежели *gameLoop*, ведь ты вызываешь этот цикл только в случае, если игрок хочет сыграть.

- Сам метод представляет из себя один большой супер-метод, из-за этого очень сильно падает читабельность кода во всем проекте. Стоит подумать каким образом разбить метод на несколько подметодов.
- Здесь очень подошел бы метод по типу *getMaskedWord*, что уменьшил бы длину метода, и отпала бы необходимость комментариев, т.к. повысил бы читабельность кода, не вынуждая обозревателя погружаться в детали.
```java
// заместо
System.out.println("Загаданное слово: " + secretWord.replaceAll("[а-я]", "*"));

StringBuilder answer = new StringBuilder(secretWord.replaceAll("[а-я]", "_"));

// лучше 
StringBuilder maskedWord = getMaskedWord(secretWord);
System.out.println(MASKED_WORD_MESSAGE + maskedWord);
```
- Сбивающее с толку название переменной *answer*, хотя сама по себе выполняет роль скрытого слова, а переменная *secretWord*, наоборот как раз таки является *answer*, что очень путает.
- Опять же не стоит игнорировать *IDEA*.
```java
// вместо 
while (countMistakes != 6)
// лучше
while (true)
```
- Стоит делать циклы как можно проще, ради читабельности.
- Непонятный `answer.toString();`, который нигде не сохраняет свое значение.
```java
// вместо
for (int i = 0; i < secretWord.length(); i++) {
                if (secretWord.charAt(i) == letter) {
                    foundLetter = true;
                    for (int j = 0; j < answer.length(); j++) {
                        answer.setCharAt(i, letter);
                        answer.toString();
                    }
                }
            }

// лучше
int secretWordLength = secretWord.length();
int answerLength = answer.length();

for (int i = 0; i < secretWordLength; i++) {
                if (secretWord.charAt(i) == letter) {
                    foundLetter = true;
                    for (int j = 0; j < answerLength; j++) {
                        answer.setCharAt(i, letter);
                    }
                }
            }
```
- Также можно эту часть кода вынести в соответствующий метод.
```java
            if (foundLetter) {
                System.out.println("Есть буква.");
            } else {
                System.out.println("Нет буквы.");
                countMistakes++;
            }
```
- Такое же применимо и к этому.
```java
            if (countMistakes == 1) {
                getArtMistakes1();
            } else if (countMistakes == 2) {
                getArtMistakes2();
            } else if (countMistakes == 3) {
                getArtMistakes3();
            } else if (countMistakes == 4) {
                getArtMistakes4();
            } else if (countMistakes == 5) {
                getArtMistakes5();
            } else if (countMistakes == 6) {
                getArtMistakes6();
            }
```
- Самый большой недостаток метода это то, что он является God Method, откуда и появляются соответствующие проблемы.

# startOrEndGame

- Нарушение принципа *SRP*, метод делает слишком много - он и печатает, и считывает, и проверяет.

- Из-за выше перечисленного название метода тоже становится непонятным. В идеале это должен быть метод, который только валидирует ввод пользователя и иметь название, что-то вроде *isInputValid* или *isStartCommand*, в зависимости от намерений.

# getArtMistakes

- Не смотря на то, что проект придерживается процедурного стиля, он вполне может быть увеличен до нескольких классов. И предпочтительнее было бы сделать отдельный класс с константами, которые ты бы печатал, вместо десяти функций.
- Неподходящее название для методов; *get* - обычно этот префикс используется только для геттеров, что может сбить с толку обозревателя, подошло бы что-то вроде *printHangmanPart*.
```java
// вместо
public static void getArtMistakes0() {
        System.out.println("------");
        System.out.println("|    |");
        System.out.println("|");
        System.out.println("|");
        System.out.println("|");
        System.out.println("|");
        System.out.println("====");
    }
// etc

// лучше 
public enum HangmanStage {
    HANGMAN_STAGE_1("""
            ------
            |    |
            |
            |
            |
            |
            ====
            """),
// etc
    
    private HangmanStage(String value) {
    }
}
```

## Основные моменты для улучшения
- Разбить *gameLoop* на несколько подметодов.
- Добавить валидацию ввода и хранение уже введённых букв.
- Сделать код более читабельным через константы и осмысленные имена переменных.
- Расширить пул слов (через файл или коллекцию).
- Улучшить архитектуру (enum для виселицы, возможно отдельный класс для логики игры).

## Итог

- Работающий проект, в целом соответствующий ТЗ.
- Есть над чем поработать - основной проблемой проекта вижу *GodMethod* *gameLoop*, стоит разбить его на несколько подметодов, что сильно улучшит качество проекта. Желаю успехов!